%% TiltRotor Dynamic model
% Author: Claudio Micheli
% Vedi http://ch.mathworks.com/help/symbolic/performing-symbolic-computations.html#brvfwnf
% Stai comunque usando la convenzione 3-2-1 (ZYX) ma matlab
% moltiplica le matrici da sinistra verso destra, quindi devi scriverle in
% senso opposto -> XYZ 
clear all 
close all

%% Rotation matrix
syms phi theta psi real

R_x = [1 0 0 ; 0 cos(phi) sin(phi); 0 -sin(phi) cos(phi)];
R_y = [cos(theta) 0 -sin(theta); 0 1 0 ; sin(theta) 0 cos(theta)];
R_z = [cos(psi) sin(psi) 0 ; -sin(psi) cos(psi) 0 ; 0 0 1];

R_be = R_x*R_y*R_z;         % Rotation matrix from Earth to Body

R_eb = R_be';               % Rotation matrix from Body to Earth

R_PiB = R_x*R_z;            % Rotation matrix from Body to Propeller Group

R_BPi = R_PiB';              % Rotation matrix from Propeller Group to Body!

%% External forces and torques
n_rotors = 4;
syms Kt Kq  m integer                             % Aerodinamic coefficients
syms omega_1 omega_2 omega_3 omega_4 alpha_1 alpha_2 alpha_3 alpha_4 real         % Angular velocities of the rotors
syms  b integer                                    %length between rotor and COG
g = 9.81;
Fg = m*[ ;0; 0; g];

%Propeller Thrusts 
%Remember -> we are using NED system, thus thrust is NEGATIVE 
T_p1 = [ 0; 0; -Kt*omega_1^2];
T_p2 = [ 0; 0; -Kt*omega_2^2];
T_p3 = [ 0; 0; -Kt*omega_3^2];
T_p4 = [ 0; 0; -Kt*omega_4^2];

%Propeller drag torques
% We consider POSITIVE TORQUES in CW orientation

tau_d1 = [ 0; 0; -Kq*omega_1^2];            % There is '-' sign since the drag torque is CCW
tau_d2 = [ 0; 0; Kq*omega_2^2];
tau_d3 = [ 0; 0; -Kq*omega_3^2];            % There is '-' sign since the drag torque is CCW
tau_d4 = [ 0; 0; Kq*omega_4^2];

for i=1:n_rotors
    disp('Matrice di rotazione Parziale');
    R_BPi
    R_BPi_axis = subs(R_BPi,psi,(i-1)*pi/2)       % Again, since we're using a CW numeration we must rotate CW, -> -pi/2 despite pi/2
    R_z_axis = subs(R_z',psi,(i-1)*pi/2);                                    % Rotation matrix  for the Origin of i-th group propeller

    switch i
        case 1
            disp('Matrice di rotazione 1');
           R_BPi_axis = subs(R_BPi_axis,phi,alpha_1)    % Rotation matrix from group propeller Pi to body 
           F_1 = R_BPi_axis*T_p1
           Op1 = R_z_axis * [ b; 0 ; 0];
           M_1 = cross(Op1,F_1) - R_BPi_axis *tau_d1;
        case 2
            disp('Matrice di rotazione 2');
            R_BPi_axis = subs(R_BPi_axis,phi,alpha_2)
           F_2 = R_BPi_axis*T_p2;
           Op2 = R_z_axis * [ b; 0 ; 0];
           M_2 = cross(Op2,F_2) - R_BPi_axis *tau_d2;
            
        case 3
           disp('Matrice di rotazione 3');
           R_BPi_axis = subs(R_BPi_axis,phi,alpha_3)
           F_3 = R_BPi_axis*T_p3
           Op3 = R_z_axis * [ b; 0 ; 0];
           M_3 = cross(Op3,F_3) - R_BPi_axis *tau_d3;
        case 4
           R_BPi_axis = subs(R_BPi_axis,phi,alpha_4);
           F_4 = R_BPi_axis*T_p4;
           Op4 = R_z_axis * [ b; 0 ; 0];
           M_4 = cross(Op4,F_4) - R_BPi_axis *tau_d4;
    end
end

% Overall thrust force generated by the 4 motors (function of the tilting angle) 
    F_ext = (F_1 + F_2 + F_3 + F_4);
    
    F_ext1 = subs(F_ext,alpha_1,0);
    F_ext2 = subs(F_ext1,alpha_2,0);
    F_ext3 = subs(F_ext2,alpha_3,0);
    F_ext_notilt = subs(F_ext3,alpha_4,0)
    
    
% Overall External torques
M_ext = M_1 + M_2 + M_3 + M_4;
M_ext1 = subs(M_ext,alpha_1,0);
M_ext2 = subs(M_ext1,alpha_2,0);
M_ext3 = subs(M_ext2,alpha_3,0);
M_ext_notilt = subs(M_ext3,alpha_4,0)           % Check torques when alpha_i = 0 -> standard quadcopter configuration

syms omega_1sq omega_2sq omega_3sq omega_4sq omega_hover_sq real
MM = [ F_ext; M_ext ];

MM = subs(MM,omega_1^2,omega_1sq);
MM = subs(MM,omega_2^2,omega_2sq);
MM = subs(MM,omega_3^2,omega_3sq);
MM = subs(MM,omega_4^2,omega_4sq);

%MM_param = subs(MM,alpha_3,-alpha_1);
%MM_param = subs(MM_param,alpha_4,-alpha_2);

%MM_param_jaco=  jacobian(MM_param,[omega_1sq,omega_2sq,omega_3sq,omega_4sq,alpha_1,alpha_2])

%MM_param_jaco_1 = subs(MM_param_jaco,alpha_2,0);
%MM_param_jaco_2 = subs(MM_param_jaco_1,alpha_1,0);
%risultato= MM_param_jaco_2^-1*[F_ext_notilt;M_ext_notilt];
MM_param_jaco=  jacobian(MM,[omega_1sq,omega_2sq,omega_3sq,omega_4sq,alpha_1,alpha_2,alpha_3,alpha_4])

% valuto il jacobiano nell'equilibrio
MM_param_jaco= subs(MM_param_jaco,omega_1sq,omega_hover_sq);
MM_param_jaco= subs(MM_param_jaco,omega_2sq,omega_hover_sq);
MM_param_jaco= subs(MM_param_jaco,omega_3sq,omega_hover_sq);
MM_param_jaco= subs(MM_param_jaco,omega_4sq,omega_hover_sq);

MM_param_jaco= subs(MM_param_jaco,alpha_1,0);
MM_param_jaco= subs(MM_param_jaco,alpha_2,0);
MM_param_jaco= subs(MM_param_jaco,alpha_3,0);
MM_param_jaco= subs(MM_param_jaco,alpha_4,0)


%% Provo a vedere cosa mi da la mixer matrix con angoli di tilt nulli

%Propellers information
D = 12*(0.0254);                 %[m] Propeller diameter
R = D/2;                         %[m] Propeller radius
A = pi*R^2;                      %[m^2] Disk area
ro = 1.225;                      %[kg*m^-3] Air density
nb = 2;                          %[1] Number of blades
ChordAv = .01;                   %[m] Average chord length
Ab = nb*R*ChordAv;               %[m] Blade area
sigma = Ab/A;                    %[1] Solid ratio
Ct = 0.011859;                   %[1] Thrust coefficent
Cq = 0.00091322;                 %[1] Torque coefficent
tau = 0.055257;                  %[s] Motor+Propeller time constant
x1 = [6.0312 80.4859];           %RPM vs THROTTLE: Y = m*X + q; x1 = [m q]
Kt = Ct*ro*A*R^2;
Kt_sigma = 1.0832e-07;
Kq = Cq*ro*A*R^3;
OMEhov = sqrt((m*g/Kt)/4);       % Angular velocity at Hovering
omega_hover = OMEhov;            % Conversion nomeclature :)

% Ricavata come [F_ext(3);M_ext] e poi fai il jacobiano
Mixer_matrix_raw = [F_ext(3);M_ext];
K_mix = subs(Mixer_matrix_raw,omega_1^2,omega_1sq);
K_mix = subs(K_mix,omega_2^2,omega_2sq);
K_mix = subs(K_mix,omega_3^2,omega_3sq);
K_mix = subs(K_mix,omega_4^2,omega_4sq);

K_mix = jacobian(K_mix,[omega_1sq,omega_2sq,omega_3sq,omega_4sq]);
% Per ottenere K devi sostituire agli angoli di tilt il valore 0 (neutral
% position)

K = [  -Kt,   -Kt,   -Kt,  -Kt;
    0, -Kt*b,     0, Kt*b;
 Kt*b,     0, -Kt*b,    0;
   Kq,   -Kq,    Kq,  -Kq];
Kinv = inv(K);
Kinv*[-15;0;0;0]            % FUNZIONA, quindi la matrice è giusta, bisogna risolvere introducendo gli alpha

%% Ricavo le relazioni non lineari per ricavare le alpha
syms Fx Fy real;
Eqn_Fx = subs(F_ext(1),alpha_4,-alpha_2);
Eqn_Fx = Eqn_Fx - Fx;
disp('relazione alpha_2(Fx,omega_2,omega_4)');
solve(Eqn_Fx,alpha_2)
% Dovrebbe venire
% -asin(Fx/(Kt*(omega_2^2 + omega_4^2)))
%  pi + asin(Fx/(Kt*(omega_2^2 + omega_4^2)))

Eqn_Fy =subs(F_ext(2),alpha_3,-alpha_1);
Eqn_Fy =Eqn_Fy - Fy;
disp('relazione alpha_1(Fx,omega_1,omega_3)');
solve(Eqn_Fy,alpha_1)

Eqn_Fz = subs(F_ext(3),alpha_3,-alpha_1);
Eqn_Fz = subs(Eqn_Fz,alpha_4,-alpha_2);
% A questo punto piloti la Thrust modificando la velocità angolare di
% rotazione


%Risultato
% asin(Fy/(Kt*(omega_1^2 + omega_3^2)))
%  pi - asin(Fy/(Kt*(omega_1^2 + omega_3^2)))
