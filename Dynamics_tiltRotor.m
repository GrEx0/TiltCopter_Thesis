%% TiltRotor Dynamic model
% Author: Claudio Micheli
% Vedi http://ch.mathworks.com/help/symbolic/performing-symbolic-computations.html#brvfwnf
% Stai comunque usando la convenzione 3-2-1 (ZYX) ma matlab
% moltiplica le matrici da sinistra verso destra, quindi devi scriverle in
% senso opposto -> XYZ 
clear all 
close all

%% Rotation matrix
syms phi theta psi 

R_x = [1 0 0 ; 0 cos(phi) sin(phi); 0 -sin(phi) cos(phi)];
R_y = [cos(theta) 0 -sin(theta); 0 1 0 ; sin(theta) 0 cos(theta)];
R_z = [cos(psi) sin(psi) 0 ; -sin(psi) cos(psi) 0 ; 0 0 1];


R_be = R_x*R_y*R_z;         % Rotation matrix from Earth to Body

R_eb = R_be';               % Rotation matrix from Body to Earth

R_BPi = R_x*R_z;            % Rotation matrix from Propeller group to Body


%% Translational model
n_rotors = 4;
syms Kt Kq  m integer                             % Aerodinamic coefficients
syms omega_1 omega_2 omega_3 omega_4 real         % Angular velocities of the rotors
syms b integer                                    %length between rotor and COG
g = 9.81;
Fg = m*[ ;0; 0; g];

%Propeller Thrusts 
T_p1 = [ 0 0 Kt*omega_1^2];
T_p2 = [ 0 0 Kt*omega_2^2];
T_p3 = [ 0 0 Kt*omega_3^2];
T_p4 = [ 0 0 Kt*omega_4^2];

%Propeller drag torques
tau_d1 = [ 0; 0; Kq*omega_1^2];
tau_d2 = [ 0; 0; Kq*omega_2^2];
tau_d3 = [ 0; 0; Kq*omega_3^2];
tau_d4 = [ 0; 0; Kq*omega_4^2];

for i=1:n_rotors
    
    R_BPi_axis = subs(R_BPi,psi,(i-1)*pi/2);
    R_BPi_axis = subs(R_BPi_axis,phi,sym(strcat('alpha_',int2str(i))) );    % Rotation matrix from group propeller Pi to body
    R_z_axis = subs(R_z,psi,(i-1)*pi/2);                                    % Rotation matrix  for the Origin of i-th group propeller
    switch i
        case 1
           F_1 = R_BPi_axis*T_p1';
           Op1 = R_z_axis * [ b; 0 ; 0];
           M_1 = dot(Op1,F_1) - R_BPi_axis *tau_d1;
        case 2
           F_2 = R_BPi_axis*T_p2';
           Op2 = R_z_axis * [ b; 0 ; 0];
           M_2 = dot(Op2,F_2) - R_BPi_axis *tau_d2;
            
        case 3
           F_3 = R_BPi_axis*T_p3';
           Op3 = R_z_axis * [ b; 0 ; 0];
           M_3 = dot(Op3,F_3) - R_BPi_axis *tau_d3;
        case 4
           F_4 = R_BPi_axis*T_p4';
           Op4 = R_z_axis * [ b; 0 ; 0];
           M_4 = dot(Op4,F_4) - R_BPi_axis *tau_d4;
    end
end
    F_ext = (F_1 + F_2 + F_3 + F_4);            % Overall thrust force generated by the 4 motors (function of the tilting angle) 
                                               

%% Momentum equilibrium






