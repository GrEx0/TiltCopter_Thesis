%% TiltRotor Dynamic model
% Author: Claudio Micheli
% Vedi http://ch.mathworks.com/help/symbolic/performing-symbolic-computations.html#brvfwnf
% Stai comunque usando la convenzione 3-2-1 (ZYX) ma matlab
% moltiplica le matrici da sinistra verso destra, quindi devi scriverle in
% senso opposto -> XYZ 
clear all 
close all

%% Rotation matrix
syms phi theta psi 

R_x = [1 0 0 ; 0 cos(phi) sin(phi); 0 -sin(phi) cos(phi)];
R_y = [cos(theta) 0 -sin(theta); 0 1 0 ; sin(theta) 0 cos(theta)];
R_z = [cos(psi) sin(psi) 0 ; -sin(psi) cos(psi) 0 ; 0 0 1];


R_be = R_x*R_y*R_z;         % Rotation matrix from Earth to Body

R_eb = R_be';               % Rotation matrix from Body to Earth

R_Pib = R_x*R_z;            % Rotation matrix from Propeller group to Body


%% Translational model
n_rotors = 4;
syms Kt Kq  m integer                             % Aerodinamic coefficients
syms omega_1 omega_2 omega_3 omega_4 real    % Angular velocities of the rotors

g = 9.81;
Fg = m*[ ;0; 0; g];

%Thrusts 
T_p1 = [ 0 0 Kt*omega_1^2];
T_p2 = [ 0 0 Kt*omega_2^2];
T_p3 = [ 0 0 Kt*omega_3^2];
T_p4 = [ 0 0 Kt*omega_4^2];


for i=1:n_rotors
    
    R_partial = subs(R_Pib,psi,(i-1)*pi/2);
    R_partial = subs(R_partial,phi,sym(strcat('alpha_',int2str(i))) );
    switch i
        case 1
           F_1 = R_partial*T_p1';
        case 2
           F_2 = R_partial*T_p2';
        case 3
           F_3 = R_partial*T_p3';
        case 4
           F_4 = R_partial*T_p4';
    end
end
    F_ext = (F_1 + F_2 + F_3 + F_4);            % Overall thrust force generated by the 4 motors (function of the tilting angle) 
                                               

